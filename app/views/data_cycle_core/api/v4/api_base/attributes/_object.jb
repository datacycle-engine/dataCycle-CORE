# frozen_string_literal: true

json ||= {}

key_name = attribute_key(key, definition)
api_property_definition = api_definition(definition)
new_fields = subtree_for(key_name, options[:fields])
new_include = subtree_for(key_name, options[:include])

object_options = { fields: new_fields, include: new_include, field_filter: options[:field_filter] }
object_properties = {}
object_properties['@type'] = api_property_definition.dig('type') if api_property_definition.dig('type').present?

ordered_validation_properties(validation: definition).each do |o_key, o_definition|
  next if options[:field_filter] && new_fields.present? && !valid_key?(attribute_key(o_key, o_definition), object_options) && api_property_definition.dig('transformation', 'method') != 'merge_object'

  key_new = attribute_key(o_key, o_definition)

  data_value = load_object_value_object(content, key, o_key, value.try(o_key), options[:languages], o_definition)

  object_properties[key_new.camelize(:lower)] = data_value if data_value.present?
end

if api_property_definition.dig('transformation', 'method') == 'unwrap' || api_property_definition.dig('transformation', 'method') == 'merge_object'
  json.merge! object_properties
else
  json[key_name] = object_properties
end

json
