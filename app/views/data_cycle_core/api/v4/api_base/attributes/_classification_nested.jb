# frozen_string_literal: true

json ||= {}
key_new = attribute_key(key, definition)
new_id = [
  content.id.sub(/(.*)-(\w+)$/, '\1'),
  (content.id.sub(/(.*)-(\w+)$/, '\2').hex ^ Digest::MD5.hexdigest(key)[0..11].hex).to_s(16).rjust(12, '0')
].join('-')

api_property_definition = api_definition(definition)

json['@id'] = new_id
json['@type'] = api_property_definition['types']

new_options = options.dup
new_options[:fields] = subtree_for(key_new, options[:fields]).map { |fields| fields[1..-1] }
new_options[:include] = subtree_for(key_new, options[:include]).map { |includes| includes[1..-1] }
new_options[:languages] = options[:languages]
new_options[:full] = included_attribute?(key_new, options[:include]) || included_attribute?(key_new, options[:fields])

classification_aliases = load_value_object(content, key, value, options[:languages], api_property_definition, options[:expand_language])&.primary_classification_aliases

classification_json = render 'classifications', classification_aliases: classification_aliases, key: key_new, definition: {}, options: new_options

if options[:include].map(&:first).include?(key_new) || options[:fields].map(&:first).include?(key_new)
  json['dc:multilingual'] = (content.embedded? ? options.dig(:translatable_embedded) || false : content.translatable?) if options[:field_filter] == false || (included_attribute?('dc:multilingual', options[:include]) || included_attribute?('dc:multilingual', options[:fields]))
  json['dc:translation'] = content.available_locales if options[:field_filter] == false || (included_attribute?('dc:translation', options[:include]) || included_attribute?('dc:translation', options[:fields]))
  json['dc:classification'] = classification_json[key_new]
end

if classification_json[key_new].present?
  {
    key_new => [json.reject { |_k, v| v.blank? }]
  }
else
  {}
end
