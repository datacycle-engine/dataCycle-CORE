# frozen_string_literal: true

json ||= {}
key_new = attribute_key(key, definition)
new_id = [
  content.id.sub(/(.*)-(\w+)$/, '\1'),
  (content.id.sub(/(.*)-(\w+)$/, '\2').hex ^ Digest::MD5.hexdigest(key)[0..11].hex).to_s(16).rjust(12, '0')
].join('-')

api_property_definition = api_definition(definition)

json['@id'] = new_id
json['@type'] = api_property_definition['types']

new_options = options.dup
new_options[:fields] = subtree_for(key_new, options[:fields]).pluck(1..-1)
new_options[:include] = subtree_for(key_new, options[:include]).pluck(1..-1)
new_options[:full] = included_attribute?(key_new, options[:include]) || included_attribute?(key_new, options[:fields])
new_options = inherit_options(new_options, options)

classification_aliases = load_value_object(content, key, value, options[:languages], api_property_definition, options[:expand_language])&.primary_classification_aliases

classification_json = render 'classifications', classification_aliases:, key: key_new, definition: {}, options: new_options

if new_options[:full]
  json['dc:multilingual'] = (content.embedded? ? options.dig(:translatable_embedded) || false : content.translatable?) if options[:field_filter] == false || (included_attribute?('dc:multilingual', options[:include]) || included_attribute?('dc:multilingual', options[:fields]))
  json['dc:translation'] = content.available_locales if options[:field_filter] == false || (included_attribute?('dc:translation', options[:include]) || included_attribute?('dc:translation', options[:fields]))
  json['dc:classification'] = classification_json[key_new]
end

if classification_json[key_new].present?
  {
    key_new => [json.reject { |_k, v| v.blank? }]
  }
else
  {}
end
